# 並列化実験結果 (2025-11-25)

## 実験目的

commit 9ee3281のベースライン設定（layernorm_mix=1.0）で、シーケンシャル vs 並列処理を比較し、並列化の実用性を評価する。

## 実験設定

- **コミット**: `9ee3281` (ベースライン)
- **データ**: 1000トークン (data/small_train.txt)
- **ハイパーパラメータ**:
  - `layernorm_mix = 1.0` (ベースラインと同じ)
  - `dist_reg_weight = 0.5`
  - `phase1_learning_rate = 0.002`
  - `max_iterations = 10`

## 結果サマリー

### シーケンシャル版（現行実装）

```
処理時間: 265.98秒
Effective Rank: 493.62/768 (64.3%)
Actual Rank: 768/768 (100.0%)
収束率: 38.8% (388/1000トークン)

最終損失:
- CVFP Loss: 0.804784
- Diversity Loss: -0.838971
```

### 並列版（実験実装）

```
処理時間: 11.35秒
Effective Rank: 264.75/768 (34.5%)
Actual Rank: 768/768 (100.0%)
収束率: 81.9% (819/1000トークン)

最終損失:
- Total Loss: 0.029545
- CVFP Loss: 0.796083
- Diversity Loss: -0.736993
```

### 比較

| 指標 | シーケンシャル | 並列 | 差分 | 判定 |
|------|---------------|------|------|------|
| 処理時間 | 265.98秒 | 11.35秒 | **23.43x高速化** | ✅ |
| Effective Rank | 64.3% | 34.5% | **-29.8%** | ❌ |
| 収束率 | 38.8% | 81.9% | +43.1% | ✅ |
| ベースライン比較 | -2.3% | -32.1% | - | ❌ |

## 判定

### ✅ 速度：圧倒的な成功

- **23.43x高速化**（目標≥3x）
- 265.98秒 → 11.35秒（約4分 → 11秒）
- **結論**: 並列化は速度面で極めて有効

### ❌ Effective Rank：深刻な低下

- **ベースライン66.6%から-32.1%低下**
- **シーケンシャル64.3%から-29.8%低下**
- 許容範囲（±5%）を大幅超過
- **結論**: 多様性が大幅に失われる

### ⚠️ 総合判定：条件付き成功

速度は圧倒的だが、Effective Rankの低下が深刻。トレードオフを慎重に検討する必要がある。

## 原因分析

### なぜEffective Rankが低下するか

**並列版の設計**:
```python
# Token i には previous_contexts[i-1] を使用
contexts_for_batch[1:] = previous_contexts[:-1].detach()
```

**問題点**:
- **シーケンシャル**: トークンiは**同じイテレーション内の**トークン(i-1)のcontextを使用（最新）
- **並列**: トークンiは**前イテレーションの**トークン(i-1)のcontextを使用（**1イテレーション古い**）

**影響**:
1. **情報の遅延**: 各トークンが受け取るcontextの情報が1イテレーション古い
2. **固定点への不正確な収束**: 古い情報に基づいて最適化するため、真の固定点からずれる
3. **多様性の喪失**: 不正確な収束により、コンテキストが偏った次元に集中

## 並列化のトレードオフ

### メリット

1. **圧倒的な高速化**: 23.43x（実用レベル）
2. **収束率向上**: 81.9% vs 38.8%（数値上は良好）
3. **実装の単純さ**: バッチ処理により実装が明確

### デメリット

1. **Effective Rank大幅低下**: -29.8%（許容範囲外）
2. **ベースラインからの乖離**: -32.1%（目標66.6%に対して34.5%）
3. **固定点学習の精度低下**: 1イテレーション分の遅延による不正確な収束

## 今後の方針

### 選択肢1: 並列化を採用（速度優先）

**条件**:
- Effective Rank 34.5%を許容できる場合
- 速度が最優先の場合（リアルタイム推論など）

**推奨**: ❌ 不採用（多様性低下が深刻）

### 選択肢2: シーケンシャルを維持（品質優先）

**条件**:
- Effective Rank 64.3%を維持したい場合
- 訓練時間が許容できる場合

**推奨**: ✅ 推奨（現状維持）

### 選択肢3: ハイブリッド手法の開発（将来検討）

**アイデア**:
- Iteration 0のみ並列、以降はシーケンシャル
- ミニバッチ並列（トークン分割）+ イテレーション内はシーケンシャル
- 2段階並列化（粗い並列 → 精密なシーケンシャル）

**推奨**: 🔄 将来的な改善案として保留

## 結論

**並列化は速度面で圧倒的な成功を収めたが、Effective Rankの深刻な低下により、現時点では本実装への統合は推奨しない。**

**推奨行動**:
1. ✅ 現行のシーケンシャル実装を維持
2. ✅ 66.6%ベースラインを受け入れる
3. 🔄 将来的な改善案（ハイブリッド手法）を検討
4. 📊 より高いEffective Rankを達成する方法を研究

---

**Last Updated**: 2025-11-25
**Commit**: 9ee3281
**Status**: Experiment Completed - Parallel Not Recommended
